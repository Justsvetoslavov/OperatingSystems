## Задачи

1. (05-a-2000) Сменете вашия prompt с нещо по желание. После върнете оригиналния обратно.

2. (05-a-2100) Редактирайте вашия .bash_profile файл, за да ви поздравява (или да изпълнява някаква команда по ваш избор) всеки път, когато влезете в системата.

3. (05-b-2000) Да се напише shell скрипт, който приканва потребителя да въведе низ (име) и изпечатва "Hello, низ".  

4. (05-b-2800) Да се напише shell скрипт, който приема точно един параметър и проверява дали подаденият му параметър се състои само от букви и цифри.

5. (05-b-3100) Да се напише shell скрипт, който приканва потребителя да въведе низ - потребителско име на потребител от системата - след което извежда на стандартния изход колко активни сесии има потребителят в момента.  

6. (05-b-3200) Да се напише shell скрипт, който приканва потребителя да въведе пълното име на директория и извежда на стандартния
изход подходящо съобщение за броя на всички файлове и всички директории в нея.

7. (05-b-3300) Да се напише shell скрипт, който чете от стандартния вход имената на 3 файла, обединява редовете на първите два (man paste), подрежда ги по азбучен ред и резултата записва в третия файл.

8. (05-b-3400) Да се напише shell скрипт, който чете от стандартния вход име на файл и символен низ, проверява дали низа се съдържа във файла и извежда на стандартния изход кода на завършване на командата с която сте проверили наличието на низа. <br />
NB!  

9. (05-b-4200) Имате компилируем (a.k.a няма синтактични грешки) source file на езика C. <br />
Напишете shell script, който да покaзва колко е дълбоко най-дълбокото nest-ване (влагане).
Примерен .c файл:
```
#include <stdio.h>

int main(int argc, char *argv[]) {

  if (argc == 1) {
		printf("There is only 1 argument");
  } else {
		printf("There are more than 1 arguments");
  }

  return 0;
}
```
Тук влагането е 2, понеже имаме main блок, а вътре в него if блок. <br />
Примерно извикване на скрипта: <br />
```
./count_nesting sum_c_code.c

# Изход:
The deepest nesting is 2 levels deep.
```

10. (05-b-4301) Напишете shell script, който автоматично да попълва файла указател от предната задача по подадени аргументи:
- име на файла указател;
- пълно име на човека (това, което очакваме да е в /etc/passwd);
- избран за него nickname;

Файлът указател нека да е във формат:
```
<nickname, който лесно да запомните> <username в os-server>
// може да сложите и друг delimiter вместо интервал
```

```
Примерно извикване:
./pupulate_address_book myAddressBook "Ben Dover" uncleBen
```

Добавя към myAddressBook entry-то:
```
uncleBen <username на Ben Dover в os-server>
```
***Бонус: Ако има няколко съвпадения за въведеното име (напр. има 10 човека Ivan Petrov в /etc/passwd), всички те да се показват на потребителя, заедно с пореден номер >=1, след което той да може да въведе някой от номерата (или 0 ако не си хареса никого), и само избраният да бъде добавен към указателя.

11. (05-b-4400) Напишете shell script, който да приема параметър име на директория, от която взимаме файлове, и незадължително(optional) експлицитно име на директория, в която ще копираме файлове. Скриптът да копира файловете със съдържание, променено преди по-малко от 45 мин, от първата директория във втората директория. Ако втората директория не е подадена по име, нека да получи такова от днешната дата във формат, който ви е удобен. При желание новосъздадената директория да се архивира.

12. (05-b-4500) Да се напише shell скрипт, който получава при стартиране като параметър в командния ред идентификатор на потребител. Скриптът периодично (sleep(1)) да проверява дали потребителят е log-нат, и ако да - да прекратява изпълнението си извеждайки на стандартния изход подходящо съобщение.

13. (05-b-4600) Да се напише shell скрипт, който валидира дали дадено цяло число попада в целочислен интервал. <br />
Скриптът приема 3 аргумента: числото, което трябва да се провери; лява граница на интервала; дясна граница на интервала. <br />
Скриптът да връща exit status: <br />
- 4, когато броят на аргументите е различен от 3
- 3, когато поне един от трите аргумента не е цяло число
- 2, когато границите на интервала са обърнати
- 1, когато числото не попада в интервала
- 0, когато числото попада в интервала

14. (05-b-4700) Да се напише shell скрипт, който форматира големи числа, за да са по-лесни за четене. <br />
Като пръв аргумент на скрипта се подава цяло число. <br />
Като втори незадължителен аргумент се подава разделител. <br />  
По подразбиране цифрите се разделят с празен интервал. <br />

15. (05-b-4800) Да се напише shell скрипт, който приема файл и директория. <br />  
Скриптът проверява в подадената директория и нейните под-директории дали съществува копие на подадения файл и отпечатва имената на намерените копия, ако съществуват такива. <br />  
Под 'копие' разбираме файл със същото съдържание. <br />

16. (05-b-5500) Да се напише shell script, който генерира HTML таблица съдържаща описание на потребителите във виртуалката ви. Таблицата трябва да има:
- заглавен ред с имената нa колоните
- колони за username, group, login shell, GECOS field (https://en.wikipedia.org/wiki/Gecos_field)

Пример:
```
$ ./passwd-to-html.sh > table.html
$ cat table.html
<table>
  <tr>
    <th>Username</th>
    <th>group</th>
    <th>login shell</th>
    <th>GECOS</th>
  </tr>
  <tr>
    <td>root</td>
    <td>root</td>
    <td>/bin/bash</td>
    <td>GECOS here</td>
  </tr>
  <tr>
    <td>ubuntu</td>
    <td>ubuntu</td>
    <td>/bin/dash</td>
    <td>GECOS 2</td>
  </tr>
</table>
```

17. (05-b-6600) Да се напише shell скрипт, който получава единствен аргумент директория и изтрива всички повтарящи се (по съдържание) файлове в дадената директория. <br />
Когато има няколко еднакви файла, да се остави само този, чието име е лексикографски преди имената на останалите дублирани файлове.

Примери:
```
$ ls .
f1 f2 f3 asdf asdf2
# asdf и asdf2 са еднакви по съдържание, но f1, f2, f3 са уникални

$ ./rmdup .
$ ls .
f1 f2 f3 asdf
# asdf2 е изтрит
```

18. (05-b-6800) Да се напише shell скрипт, който получава единствен аргумент директория и отпечатва списък с всички файлове и
директории в нея (без скритите).
До името на всеки файл да седи размера му в байтове, а до името на всяка директория да седи броят на елементите в нея
(общ брой на файловете и директориите, без скритите).
a) Добавете параметър -a, който указва на скрипта да проверява и скритите файлове и директории.

Пример:
```
$ ./list.sh .
asdf.txt (250 bytes)
Documents (15 entries)
empty (0 entries)
junk (1 entry)
karh-pishtov.txt (8995979 bytes)
scripts (10 entries)
```

19. (05-b-7000) Да се напише shell скрипт, който приема произволен брой аргументи - имена на файлове. Скриптът да прочита от стандартния вход символен низ и за всеки от зададените файлове извежда по подходящ начин на стандартния изход броя на редовете, които съдържат низа.
#NB! Низът може да съдържа интервал.

20. (05-b-7100) Да се напише shell скрипт, който приема два параметъра - име на директория и число.
Скриптът да извежда на стандартния изход имената на всички обикновени файлове във директорията, които имат размер, по-голям от подаденото число.
 
21. (05-b-7200) Да се напише shell скрипт, който приема произволен брой аргументи - имена на файлове или директории.
Скриптът да извежда за всеки аргумент подходящо съобщение:
- дали е файл, който може да прочетем
- ако е директория - имената на файловете в нея, които имат размер, по-малък от броя на файловете в директорията.

22. (05-b-7500) Напишете shell script guess, която си намисля число, което вие трябва да познате.
В зависимост от вашия отговор, програмата трябва да ви казва "надолу" или "нагоре", докато не познате числото.
Когато го познаете, програмата да ви казва с колко опита сте успели.

```
./guess (програмата си намисля 5)

Guess? 22
...smaller!
Guess? 1
...bigger!
Guess? 4
...bigger!
Guess? 6
...smaller!
Guess? 5
RIGHT! Guessed 5 in 5 tries!
```
Hint: Един начин да направите рандъм число е с $(( (RANDOM % b) + a  )), което ще генерира число в интервала [a, b].
Може да вземете a и b като параметри, но не забравяйте да направите проверката.

23. (05-b-7550) Да се напише shell скрипт, който приема параметър - име на потребител. Скриптът да прекратява изпълненито на всички
текущо работещи процеси на дадения потребител, и да извежда колко са били те. <br />
#NB! Може да тествате по същият начин като описаният в 05-b-4300. <br />

24. (05-b-7800) Да се напише shell скрипт, който намира броя на изпълнимите файлове в PATH. <br />
Hint: Предполага се, че няма спейсове в имената на директориите <br />
Hint2: Ако все пак искаме да се справим с този случай, да се разгледа IFS променливата и констуркцията while read -d <br />

25. (05-b-8000) Напишете shell script, който получава като единствен аргумент име на потребител и за всеки негов процес изписва
съобщение за съотношението на RSS към VSZ. Съобщенията да са сортирани, като процесите с най-много заета виртуална памет са най-отгоре.

Hint:
Понеже в Bash няма аритметика с плаваща запетая, за смятането на съотношението използвайте командата bc.
За да сметнем нампример 24/7, можем да: echo "scale=2; 24/7" | bc
Резултатът е 3.42 и има 2 знака след десетичната точка, защото scale=2.
Алтернативно, при липса на bc ползвайте awk.

26. Опишете поредица от команди или напишете shell скрипт, които/който при известни две директории SOURCE и DESTINATION:
- намира уникалните "разширения" на всички файлове, намиращи се някъде под SOURCE. (За простота приемаме, че в имената на файловете може да се среща символът точка '.' максимум веднъж);
- за всяко "разширение" създава по една поддиректория на DESTINATION със същото име;
- разпределя спрямо "разширението" всички файлове от SOURCE в съответните поддиректории в DESTINATION;

27. (05-b-9200) Да се напише shell скрипт, който получава произволен брой аргументи файлове, които изтрива. <br />
Ако бъде подадена празна директория, тя бива изтрита. <br />
Ако подадения файл е директория с поне 1 файл, тя не се изтрива. <br />
За всеки изтрит файл (директория) скриптът добавя ред във log файл с подходящо съобщение. <br />

а) Името на log файла да се чете от shell environment променлива, която сте конфигурирали във вашия `.bashrc`.
б) Добавете параметър `-r` на скрипта, който позволява да се изтриват непразни директории рекурсивно.
в) Добавете timestamp на log съобщенията във формата: `2018-05-01 22:51:36`

Примери:
```
$ export RMLOG_FILE=~/logs/remove.log
$ ./rmlog -r f1 f2 f3 mydir/ emptydir/
$ cat $RMLOG_FILE
[2018-04-01 13:12:00] Removed file f1
[2018-04-01 13:12:00] Removed file f2
[2018-04-01 13:12:00] Removed file f3
[2018-04-01 13:12:00] Removed directory recursively mydir/
[2018-04-01 13:12:00] Removed directory emptydir/
```

28. (05-b-9500) (Цветно принтиране) Напишете shell script color_print, който взима два параметъра. <br />

Първият може да е измежду "-r", "-g" "-b", а вторият е произволен string. <br /> 
На командата "echo" може да се подаде код на цвят, който ще оцвети текста в определения цвят. <br />
В зависимост от първия аргумент, изпринтете втория аргумен в определения цвят:
- "-r" е червено. Кодът на червеното е '\033[0;31m' (echo -e "\033[0;31m This is red")
- "-g" е зелено. Кодът на зеленото е '\033[0;32m' (echo -e "\033[0;32m This is green")
- "-b" е синьо. Кодът на синьото е '\033[0;34m' (echo -e "\033[0;34m This is blue")
Ако е подадена друга буква изпишете "Unknown colour", а ако изобщо не е подаден аргумент за цвят, просто изпишете текста. <br />

Hint: <br />
В края на скрипта си напишете: <br />
echo -e '\033[0m' <br />
за да не се прецакат цветовете на терминала. Това е цветът на "няма цвят". <br />

29. (05-b-9501) Този път програмата ви ще приема само един параметър, който е измежду ("-r", "-b", "-g", "-x"). <br />
Напишете shell script, който приема редовете от stdin и ги изпринтва всеки ред с редуващ се цвят. <br />
Цветовете вървят RED-GREEN-BLUE и цветът на първия ред се определя от аргумента. <br />
Ако е подаден аргумент "-x", то не трябва да променяте цветовете в терминала (т.е., все едно сте извикали командата cat). <br />
Hint: Не забравяйте да връщате цветовете в терминала. <br />

30. (05-b-9600) Да се напише shell скрипт, който получава произволен брой аргументи файлове, които изтрива. <br />
Ако бъде подадена празна директория, тя бива изтрита. Ако подадения файл е директория с поне 1 файл, тя не се изтрива. <br />

Да се дефинира променлива BACKUP_DIR (или друго име), в която: 
- изтритите файлове се компресират и запазват
- изтритите директории се архивират, комприсират и запазват
- имената на файловете е "filename_yyyy-mm-dd-HH-MM-SS.{gz,tgz}", където filename е оригиналното име на файла (директорията) преди да бъде изтрит

а) Добавете параметър -r на скрипта, който позволява да се изтриват непразни директории рекурсивно и съответно да се запазят в BACKUP_DIR

Примери:
```
$ export BACKUP_DIR=~/.backup/

# full-dir/ има файлове и не може да бъде изтрита без параметър -r
$ ./trash f1 f2 full-dir/ empty-dir/
error: full-dir/ is not empty, will not detele
$ ls $BACKUP_DIR
f1_2018-05-07-18-04-36.gz
f2_2018-05-07-18-04-36.gz
empty-dir_2018-05-07-18-04-36.tgz

$ ./trash -r full-dir/

$ ls $BACKUP_DIR
f1_2018-05-07-18-04-36.gz
f2_2018-05-07-18-04-36.gz
full-dir_2018-05-07-18-04-50.tgz
empty-dir_2018-05-07-18-04-36.tgz

# можем да имаме няколко изтрити файла, които се казват по един и същ начин
$ ./trash somedir/f1

$ ls $BACKUP_DIR
f1_2018-05-07-18-04-36.gz
f1_2018-05-07-18-06-01.gz
f2_2018-05-07-18-04-36.gz
full-dir_2018-05-07-18-04-50.tgz
empty-dir_2018-05-07-18-04-36.tgz
```





