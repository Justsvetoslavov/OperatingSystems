# 2020-SE-01
Напишете shell скрипт, който получава два задължителни позиционни параметъра:
- име на файл (bar.csv)
- име на директория.
Директорията може да съдържа текстови файлове с имена от вида foobar.log, всеки от които има съдържание от следния вид:

Пример 1 (loz-gw.log):
``` 
Licensed features for this platform:
Maximum Physical Interfaces : 8
VLANs : 20
Inside Hosts : Unlimited
Failover : Active/Standby
VPN-3DES-AES : Enabled
*Total VPN Peers : 25
VLAN Trunk Ports : 8
This platform has an ASA 5505 Security Plus license.
Serial Number: JMX00000000
Running Activation Key: 0e268e0c
```
Пример 2 (border-lozenets.log):
```
Licensed features for this platform:
Maximum Physical Interfaces : 4
VLANs : 16
Inside Hosts : Unlimited
Failover : Active/Active
VPN-3DES-AES : Disabled
*Total VPN Peers : 16
VLAN Trunk Ports : 4
This platform has a PIX 535 license.
Serial Number: PIX5350007
Running Activation Key: 0xd11b3d48
``` 
Имената на лог файловете (loz-gw, border-lozenets) определят даден hostname, а съдържанието
им дава детайли за определени параметри на съответният хост. <br />
Файлът bar.csv, който трябва да се генерира от вашия скрипт, е т.н. CSV (comma separated values)
файл, тоест текстови файл - таблица, на който полетата на всеки ред са разделени със запетая. <br />
Първият ред се ползва за определяне на имената на колоните. <br />
Скриптът трябва да създава файла bar.csv на база на log файловете в директорията. <br />
Генерираният CSV файл от директория, която съдържа само loz-gw.log и border-lozenets.log би изглеждал
така: <br />
```
hostname,phy,vlans,hosts,failover,VPN-3DES-AES,peers,VLAN Trunk Ports,license,SN,key
loz-gw,8,20,Unlimited,Active/Standby,Enabled,25,8,ASA 5505 Security Plus,JMX00000000,0e268e0c
border-lozenets,4,16,Unlimited,Active/Active,Disabled,16,4,PIX 535,PIX5350007,0xd11b3d48
```
Полетата в генерирания от скрипта CSV файл не трябва да съдържат излишни trailing/leading
интервали. За улеснение, приемете, че всички whitespace символи във входните файлове са символа
“интервал”.

# 2020-SE-02

Напишете shell скрипт, който приема задължителен параметър - име на файл. <br />
Файлът е log файл на HTTP сървър, в който се записват всички получени от сървъра request-и, които клиентите са изпратили. <br />
Файлът е текстови, като на всеки ред има информация от следния вид:
```
35.223.122.181 dir.bg - [03/Apr/2020:17:25:06 -0500] GET / HTTP/1.1 302 0 "-" "Zend_Http_Client"
94.228.82.170 del.bg - [03/Apr/2020:17:25:06 -0500] POST /auth HTTP/2.0 400 153 "foo bar" "<UA>"
```
Всеки ред на файла се състои от полета, разделени с интервал. <br />
Описание на полетата с пример спрямо първият ред от горните:
- адрес на клиент - 35.223.122.181
- име на виртуален хост (сайт) - dir.bg
- име на потребител - -
- timestamp на заявката - [03/Apr/2020:17:25:06 -0500]
- заявка - GET / HTTP/1.1 - състои се от три компонента, разделени с интервал:
    - метод на заявката (за удобство приемаме, че може да има само GET и POST заявки)
    - ресурсен идентификатор
    - протокол (приемаме, че може да има само HTTP/1.0, HTTP/1.1 и HTTP/2.0 протоколи)
- код за статус на заявката - 302
- брой байтове - 0
- referer - "-" - ограден в двойни кавички, подава се от HTTP клиента, произволен низ
- user agent - "Zend_Http_Client" - ограден в двойни кавички, подава се от HTTP клиента, произволен низ

За всеки от top 3 сайта, към които има най-много заявки, скриптът трябва да изведе в долния формат:
- брой на HTTP/2.0 заявките
- брой на не-HTTP/2.0 заявките
- top 5 клиента, направили най-много заявки, завършили с код, по-голям от 302 (и броя на съответните им зявки)
```
dir.bg HTTP/2.0: 0 non-HTTP/2.0: 5
del.bg HTTP/2.0: 5 non-HTTP/2.0: 0
5 94.228.82.170
2 34.73.112.204
1 185.217.0.138
```

# 2020-SE-03

Под пакет ще разбираме директория, която има следната структура:
```
<name>
    |-- version
    |-- tree
        |...
```
- `<name>` е името на пакета
- version е текстов файл, който съдържа низ от вида 1.2.3-4 и нищо друго
- tree е директория с произволно съдържание.

За да получим архив на пакет, архивираме (tar) и компресираме (xz) съдържанието на директорията tree. <br />
Под хранилище ще разбираме директория, която има следната структура:
```
<repo name>
    |-- db
    |-- packages
        |...
```
- `<repo name>` е името на хранилището
- db е текстов файл, чиито редове имат вида:
    - `<package name>`-`<package version>` `<package checksum>` и са сортирани лексикографски.
- Директорията packages съдържа архиви с имена `<package checksum>`.tar.xz, които съответстват на редове в db. <br />
Под `<package checksum>` имаме предвид sha256 сумата на архива на пакета. <br />

Напишете скрипт repo_add.sh, който приема два аргумента - път до хранилище и път до пакет,
който добавя пакета в хранилището. <br />
Ако същата версия на пакет вече съществува, архивът се заменя с новата версия. <br />
В противен случай, новата версия се добавя заедно с другите. <br />

Заб: Първо си проектирайте общия алгоритъм на работа. <br />

Примерно хранилище:
```
myrepo
    |-- db
    |-- packages
        |-- 6e3549438bc246b86961b2e8c3469321ca22eabd0a6c487d086de7a43a0ef766.tar.xz
        |-- 66b28e48161ba01ae25433b9ac4086a83b14d2ee49a62f2659c96514680ab6e8.tar.xz
        |-- 99c934ad80bd9e49125523c414161e82716b292d4ed2f16bb977d6db7e13d9bc.tar.xz
```
Със съдържание на db:
```
glibc-2.31-2 6e3549438bc246b86961b2e8c3469321ca22eabd0a6c487d086de7a43a0ef766
zlib-1.1.15-8 66b28e48161ba01ae25433b9ac4086a83b14d2ee49a62f2659c96514680ab6e8
zlib-1.2.11-4 99c934ad80bd9e49125523c414161e82716b292d4ed2f16bb977d6db7e13d9bc
```
Примерен пакет:
```
zlib
    |-- version # contains ’1.2.11-3’
    |-- tree
        |...
```
Съдържание на хранилището след изпълнение на ./repo-add.sh myrepo zlib
```
myrepo
    |-- db
    |-- packages
        |-- 6e3549438bc246b86961b2e8c3469321ca22eabd0a6c487d086de7a43a0ef766.tar.xz
        |-- 66b28e48161ba01ae25433b9ac4086a83b14d2ee49a62f2659c96514680ab6e8.tar.xz
        |-- b839547ee0aed82c74a37d4129382f1bd6fde85f97c07c5b705eeb6c6d69f162.tar.xz
        |-- 99c934ad80bd9e49125523c414161e82716b292d4ed2f16bb977d6db7e13d9bc.tar.xz
```
Със съдържание на db:
```
glibc-2.31-2 6e3549438bc246b86961b2e8c3469321ca22eabd0a6c487d086de7a43a0ef766
zlib-1.1.15-8 66b28e48161ba01ae25433b9ac4086a83b14d2ee49a62f2659c96514680ab6e8
zlib-1.2.11-3 b839547ee0aed82c74a37d4129382f1bd6fde85f97c07c5b705eeb6c6d69f162
zlib-1.2.11-4 99c934ad80bd9e49125523c414161e82716b292d4ed2f16bb977d6db7e13d9bc
```

# 2020-SE-04
Напишете скрипт, който приема два аргумента - имена на директории. <br />
Първата (SRC) съществува, докато втората (DST) трябва да бъде създадена от скрипта. <br />
Директорията SRC и нейните поддиректории може да съдържат файлове, чиито имена завършат на .jpg. <br />
Имената на файловете може да съдържат интервали, както и поднизове, оградени със скоби, например:
```
A single (very ugly) tree (Outdoor treks) 2.jpg
Falcons.jpg
Gorgonzola (cheese).jpg
Leeches (two different ones) (Outdoor treks).jpg
Pom Pom Pom.jpg
```
За даден низ ще казваме, че е почистен, ако от него са премахнати leading и trailing интервалите и всички последователни интервали са сведени до един. <br />
За всеки файл дефинираме следните атрибути: <br />
- заглавие - частта от името преди .jpg, без елементи оградени в скоби, почистен.
```
Примери:
A single tree 2
Falcons
Gorgonzola
Leeches
Pom Pom Pom
```
- албум - последният елемент от името, който е бил ограден в скоби, почистен. Ако албум е
празен стринг, ползваме стойност по подразбиране misc. 
```
Примери:
Outdoor treks
misc
cheese
Outdoor treks
misc
```
- дата - времето на последна модификация на съдържанието на файла, във формат YYYY-MM-DD
- хеш - първите 16 символа от sha256 сумата на файла. <br />
Забележка: приемаме, че в тази идеална вселена първите 16 символа от sha256 сумата са уникални за всеки файл от тези, които ще се наложи да обработваме. <br />

Скриптът трябва да създава в директория DST необходимата структура от под-директории, файлове и symlink–ове, така че да са изпълнени следните условия за всеки файл от SRC:
- DST/images/хеш.jpg - копие на съответния файл
- следните обекти са относителни symlink–ове към хеш.jpg:
```
    – DST/by-date/дата/by-album/албум/by-title/заглавие.jpg
    – DST/by-date/дата/by-title/заглавие.jpg
    – DST/by-album/албум/by-date/дата/by-title/заглавие.jpg
    – DST/by-album/албум/by-title/заглавие.jpg
    – DST/by-title/заглавие.jpg
```

# 2020-SE-05
Напишете shell скрипт, който приема 3 позиционни аргумента – две имена на файлове
и име на директория. <br />
Примерно извикване:
```
$ ./foo.sh foo.pwd config.cfg cfgdir/
```
В директорията cfgdir/ и нейните под-директории може да има файлове с имена завършващи
на .cfg. <br />
За да са валидни, тези файлове трябва да съдържат редове само в следните формати
(редовете започващи с # са коментари):
```
# internal laboratory
{ no-production };

{ volatile };

# meow configs
{ run-all; };
```
Във файла foo.pwd има описани потребителски имена (username) и MD5 хеш суми на паролите им,
с по един запис на ред, в следният формат:
```
username:password_hash
```
Също така, разполагате с команда pwgen, която генерира и извежда на STDOUT случайни пароли, и знаете, че поддържа следните два аргумента:
```
$ pwgen [ password_length ] [ number_of_passwords ]
```

Вашият скрипт трябва да валидира cfg файловете в директорията, и за тези, които не са валидни, да
извежда на STDOUT името на файла и номерирани редовете, които имат проблем, в следния формат:
```
Error in filename.cfg:
Line 1:XXXX
Line 37:YYYY
```
където XXXX и YYYY е съдържанието на съответния ред. <br />
За валидните файлове, скриптът трябва да:
- генерира config.cfg като обединение на съдържанието им;
- името на файла, без частта .cfg дефинира потребителско име.
Ако във файла с паролите не съществува запис за този потребител, то такъв да се добави и на стандартния изход да се изведе потребителското име и паролата (поне 16 символа) разделени с един интервал.

# 2020-SE-06
Под конфигурационен файл ще разбираме файл, в който има редове от вида **key=value**,
където key и value могат да се състоят от букви, цифри и знак “долна черта” (“_”). <br />
Освен това, във файла може да има празни редове; може да има произволен whitespace в началото и в края на
редовете, както и около символа “=”. <br />
Също така са допустими и коментари в даден ред: всичко след символ “#” се приема за коментар. <br />
Под `<date>` ще разбираме текущото време, върнато от командата date без параметри; под `<user>`
ще разбираме името на текущият потребител. <br />
Напишете shell скрипт set_value.sh, който приема 3 позиционни аргумента – име на конфигурационен файл, ключ (foo) и стойност (bar). <br />
Ако ключът: 
- присъства във файла с друга стойност, скриптът трябва да:
    - да закоментира този ред като сложи # в началото на реда и добави в края на реда #
edited at `<date>` by `<user>`.
    - да добави нов ред foo = bar # added at `<date>` by `<user>` точно след стария ред
- не присъства във файла, скриптът трябва да добави ред от вида foo = bar # added at
`<date>` by `<user>` на края на файла
```
Примерен foo.conf:
# route description
from = Sofia
to = Varna # my favourite city!
type = t2_1
```
Примерно извикване:
```
./set_value.sh foo.conf to Plovdiv
```
Съдържание на foo.conf след извикването:
```
# route description
from = Sofia
# to = Varna # my favourite city! # edited at Tue Aug 25 15:48:29 EEST 2020 by human
to = Plovdiv # added at Tue Aug 25 15:48:29 EEST 2020 by human
type = t2_1
```